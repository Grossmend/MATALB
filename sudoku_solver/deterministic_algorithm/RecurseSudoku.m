
% рекурсивная функция поиска решения

function [mat,imp,sol] = RecurseSudoku(mat,sol,countSolve)

[mat,imp] = CheckSolveSudoku(mat);

% если невозможное решение, выход
if imp
    return
end

% находим индексы недостающих значений
% z = find(~M(:));

% будем вставлять рекурсивным методом в ячейки, где наименьшее кол-во
% вариантов решений (нужна серьезная доработка)
arrSortNeed = allowValuesSudoku(mat);
if isempty(arrSortNeed)
    need = [];
else
    need = sortrows(arrSortNeed,2);
    need = need(:,1);
end

% если индексов недостающих значений нет, то значит решение найдено
if isempty(need)
    sol.(sprintf('solution_%d',length(fieldnames(sol)))) = mat;
    if countSolve
        % остановка рекурсивной функции
        disp('решение:')
        % печатаем решенный массив, печатаем Карл!!!
        disp(mat)
        disp('Принудительная остановка рекурсии. Выход')
        error('Принудительная остановка рекурсии. Выход')
    end
    % return только выведет на предыдущую функцию, необходим метод,
    % который прервет выполнение рекурсивной функции
    return
end

% если имеются пропущенные значения, то заполняем рекурсивно
% главная часть алгоритма рекурсивного подбираем числа от 1 до 9,
% последовательно. Нужна серьезная доработка (куда вставлять данное число)
for p = 1:9
    pat = mat;
    pat(need(1)) = p;
    [pat,~,sol] = RecurseSudoku(pat,sol,countSolve);
end

% устанавливаем ограничеие по времени
if toc > 60
    disp('Отведенное время работы алгоритма вышло. Выход')
    error('Отведенное время работы алгоритма вышло. Выход')
end

mat = pat;

return